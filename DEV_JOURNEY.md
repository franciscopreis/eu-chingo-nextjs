## ðŸŽ¯ Why and How I Built It This Way

- **Full-stack TypeScript** from database to UI - It was the first time I used Typescript throughout a full project and while I found it pretty annoying sometimes, I realize how helpful it is. So I guess I'm a strict type type of guy now.
- **Modern React** patterns and architecture - For a guy that dwelved in the DOM nightmare in the past (and stopped learning JS because of that), I have to say that React even with all its problems was a breath of fresh air. I was familiar with useState, useEffect, useRef, useMemo and hooks, before beginning the project,
- **Real authentication** with proper security - I started with endpoints (the way I knew) but ended up using server actions for this (except for logout) and I like it. It can be a little more evasive sometimes, with some profeciency it became a clean alternative. Though I must say that the traditional way was easier for me to debug (but I'm still learning)
- **Payment integration** that actually works - I wasn't planning on integrating this, but I wanted to test myself and see how hard it could be and I'm surprised by how easy that was. It required a little troubleshooting, but in the end it was an okay experience.
- **Email services** just to show that I can - I implemented this in the same vein of the payment integration, just to test myself. Overall it wasn't very hard, but testing it locally was a sketchy.
- **Responsive design** that doesn't suck on mobile - Tailwind in this regard was a great help. I only had some problems with resizing dynamic components because of hydration (which kind of sucks).
- **Feature-Based Architecture with clean separation** (or whatever the fancy name is) - I went back and forwards while choosing the architecture for my project, in part because of my poor planning regarding how my front-end will be (I'm kind of dumb, I guess), but once I knew my features and how I would present them things got easier and the final architecture seems adequate, mainly having into consideration that I would be adding more features in the future. The separation of concerns between features, and services and repository already helped a lot in terms of debugging.
- **Database and SQLite** for the first time - I've tested some DB types in the past (mainly MongoDB as part of a course I took) and it was the first time experimenting with SQL. I deliberately chose to not use a ORM (like Prism) because I wanted to directly work with SQL (who know, maybe it can get me a job) and it wasn't too difficult. I was able to do what I wanted, which wasn't much but it worked in the end. When I tried to deploy on Vercel I noticed that I couldn't use it with better-sqlite3 (I should've checked it first) but I found Turso which I recommend. I ended up creating an adapter that allows me to work with my local DB while developing, but uses Turso when in production.
- **Scripting with Node.js** - I also wrote some scripts with Node.js, which I wasn't familiar with. I'm still not very at ease with it, but it surely is powerful. I tried scripting with Python for some personal things, but never with Node. But it helped me, mainly converting JSON with all the information about the hexagrams to SQLite and later to Turso.
- The devious **Git** - I got some experience with Git. I used it in the past very superficially, just with basic commands, but here I learned a lot more. At first my commits weren't the best, I worked on several things at the same time which can make things harder if I have to go back, but by the end I was a little bit more conscious about this. I also started by writing them in English (which I guess is the best practice) and very detailed, but then I decided to just switch. I was taking more time writing the commit messages than programming so I ended up using just writing short commits in Portuguese. I had to rebase a great part of the project but in the end all worked out.
